# FeatureFlow: Dynamic Feature Module Framework

## Overview

FeatureFlow is an Android framework designed to simplify the management, installation, and loading of Dynamic Feature Modules (DFMs) using the Play Core Install API.
It provides a structured approach based on Clean Architecture principles (UI, Domain, Data layers)
and leverages modern Android development practices like Jetpack Compose, Coroutines Flow, Hilt, and DataStore.

The framework handles:
* URI-based routing to trigger feature loading.
* Checking installation status.
* Initiating and monitoring DFM installation via Play Core.
* Handling user confirmation dialogs for large downloads.
* Running pre/post-installation steps (interceptors).
* Initializing feature modules via ServiceLoader after installation.
* Dynamically loading and displaying the feature's Compose UI.
* Managing UI states (Loading, Error, Success, Confirmation Needed).
* Handling errors gracefully with retry mechanisms.

## Core Concepts

* **Dynamic Feature Module (DFM):** A part of the app that can be downloaded and installed on demand.
* **URI Routing:** Using URIs (e.g., `chase/df/route/myfeature`) to identify and request specific features.
* **Interceptors:** Custom tasks (`DFComponentInterceptor`) that can run before (pre-install) or after (post-install) a DFM installation.
* **Service Loader Initialization:** Using Java's `ServiceLoader` mechanism (`DFComponentEntry`, `DFServiceLoader`) to allow DFMs to self-register components and run initialization code after being installed and loaded into the application's ClassLoader.
* **Component Registry:** A central registry (`DFComponentRegistry`) where DFMs register their configuration (`DFComponentConfig`) and main Composable screen.

## Architecture

The framework follows a layered architecture inspired by Clean Architecture:

1.  **UI Layer (`featureflow.component.ui`, `featureflow.ui.theme`):**
    * **`DFComponentActivity`:** The host Activity responsible for receiving Intents (URIs), interacting with the ViewModel, handling Android-specific flows (like the confirmation dialog via `ActivityResultLauncher`), and displaying the appropriate Compose UI.
    * **`DFComponentViewModel`:** Manages the UI state (`DFComponentState`), processes user intents (`DFComponentIntent`), orchestrates calls to domain Use Cases, handles the lifecycle of feature loading/installation, and exposes state/events to the Activity.
    * **`DFComponentScreen`:** The default Compose screen displayed by the Activity during loading, error, or confirmation states.
    * **`DFComponentState`:** Sealed class representing the various states the UI can be in (Loading, Error, RequiresConfirmation, Success).
    * **`DFComponentIntent`:** Sealed class representing actions/events from the UI that the ViewModel needs to process.
    * **`ConfirmationEventData`:** Data class for events triggering the confirmation dialog in the Activity.

2.  **Domain Layer (`featureflow.component.domain`):**
    * Contains Use Cases encapsulating specific business logic related to feature loading and installation.
    * **`DFProcessUriUseCase`:** Parses a URI string into a structured route or identifies it as invalid.
    * **`DFLoadFeatureUseCase`:** Performs initial checks (validation, install status) when a feature load is requested and determines the next step (monitor install or run post-install steps).
    * **`DFMonitorInstallationUseCase`:** Monitors the installation progress via the `DFComponentInstaller`, maps installation states to UI states (using `DFHandleInstallationStateUseCase`), and emits events (`DFInstallationMonitoringEvent`) to the ViewModel to coordinate UI updates, confirmation dialogs, and triggering post-install steps.
    * **`DFRunPostInstallStepsUseCase`:** Executes the sequence of post-installation actions (ServiceLoader init, post-install interceptors, fetching the dynamic screen).
    * **`DFHandleInstallationStateUseCase`:** Maps detailed internal `DFInstallationState` to user-facing `DFComponentState`.
    * **`DFHandleErrorUseCase`:** Centralizes error processing logic, determining UI error state and potential persistent state updates.

3.  **Data / Infrastructure Layer (`featureflow.component.*` subpackages):**
    * Handles interactions with external dependencies and data sources.
    * **`googleplay` (`DFComponentInstaller`, `DFComponentInstallerManager`):** Abstracts interaction with the Play Core `SplitInstallManager` for checking status, installing modules, and monitoring progress. Maps Play Core states to internal `DFInstallationState`.
    * **`state` (`DFComponentStateStore`, `DFComponentStateStoreImpl`, `DFInstallationState`, etc.):** Manages application state related to features. Uses DataStore for persisting the last attempted feature URI and Kotlin Flows (`StateFlow`) for managing in-memory installation/interceptor states.
    * **`register` (`DFComponentRegistry`, `DFComponentRegistryManager`, `DFComponentEntry`, etc.):** Handles the registration of DFMs. Feature modules implement `DFComponentEntry` to register their `DFComponentConfig` and Composable screen lambda with the `DFComponentRegistry` singleton.
    * **`interceptor` (`DFInterceptor`, `DFInterceptorManager`):** Manages the execution of pre/post-install interceptor tasks defined in `DFComponentConfig`.
    * **`serviceloader` (`DFServiceLoader`, `DFServiceLoaderManager`):** Manages running `ServiceLoader` to find and initialize `DFComponentEntry` implementations from newly installed DFMs.
    * **`route` (`DFComponentUriRouteParser`, `DFComponentRoute`):** Utility for parsing URI strings into structured route objects.
    * **`di` (`AppModule`):** Provides dependencies using Hilt (SplitInstallManager, StateStore, Use Cases, Managers, etc.).

## Data Flow & Feature Loading Lifecycle

The typical flow for loading a dynamic feature via a URI:

1.  **Intent Reception:** `DFComponentActivity` receives an Intent (e.g., from a deep link `Intent.ACTION_VIEW` or internal navigation) containing a target URI.
2.  **URI Handling:** The Activity's `handleIntent` extracts the URI string.
3.  **Intent Dispatch (UI -> VM):** The Activity sends a `DFComponentIntent.ProcessUri` intent to the `DFComponentViewModel`.
4.  **URI Processing (VM):** The ViewModel uses `DFProcessUriUseCase` to parse the URI.
5.  **Feature Load Request (VM):** If the URI maps to a feature route, the ViewModel dispatches a `DFComponentIntent.LoadFeature` intent to itself.
6.  **Initial Load Check (VM -> Domain):** The ViewModel processes `LoadFeature`, invoking `DFLoadFeatureUseCase`.
7.  **Load Decision (Domain -> VM):** `DFLoadFeatureUseCase` checks if the feature is installed:
    * **Installed:** Returns `ProceedToPostInstall`.
    * **Not Installed:** Returns `ProceedToInstallationMonitoring`.
    * **Error:** Returns `Failure`.
8.  **Error Handling (VM):** If `Failure`, the ViewModel uses `DFHandleErrorUseCase` and updates `_uiState` to `DFComponentState.Error`.
9.  **Installation Path (VM -> Domain):** If `ProceedToInstallationMonitoring`, the ViewModel calls `initiateInstallation`, which invokes `DFMonitorInstallationUseCase`.
10. **Installation Monitoring (Domain -> Data -> Domain -> VM):**
    * `DFMonitorInstallationUseCase` calls `DFComponentInstaller.installComponent`.
    * `DFComponentInstallerManager` interacts with Play Core's `SplitInstallManager`, listens for state updates, and emits `DFInstallProgress` (containing `DFInstallationState` and optional raw Play state).
    * `DFMonitorInstallationUseCase` collects these updates, uses `DFHandleInstallationStateUseCase` to map `DFInstallationState` to `DFComponentState`, and emits `DFInstallationMonitoringEvent`s to the ViewModel.
11. **Monitoring Event Handling (VM):** The ViewModel collects events from `DFMonitorInstallationUseCase`:
    * `UpdateUiState`: Updates `_uiState` (e.g., Loading, Downloading, Installing).
    * `StorePendingConfirmation`: Stores `ConfirmationEventData` internally and emits it via `_eventFlow`.
    * `ClearPendingConfirmation`: Clears the internal `pendingConfirmationData`.
    * `TriggerPostInstallSteps`: Calls `executePostInstallSteps`.
    * `InstallationFailedTerminal`/`InstallationCancelledTerminal`: Updates state via `handleErrorState`, clears internal data.
12. **Confirmation Flow (VM -> UI -> VM):**
    * The Activity collects `ConfirmationEventData` from `_eventFlow`.
    * It launches the Play Core confirmation dialog using the provided `IntentSender`.
    * When the dialog finishes, the Activity's `ActivityResultLauncher` callback is triggered.
    * The Activity sends a `DFComponentIntent.UserConfirmationResult` back to the ViewModel.
    * The ViewModel's `handleUserConfirmationResult` updates state or logs the outcome (actual installation progress continues via the Play Core listener).
13. **Post-Install Path (VM -> Domain):** If `ProceedToPostInstall` (from step 7) or triggered by `TriggerPostInstallSteps` (from step 11), the ViewModel calls `executePostInstallSteps`, invoking `DFRunPostInstallStepsUseCase`.
14. **Post-Install Execution (Domain -> Data -> Domain -> VM):**
    * `DFRunPostInstallStepsUseCase` calls `DFServiceLoader.runServiceLoaderInitialization` (which finds and runs `DFComponentEntry.initialize` in the DFM).
    * It then calls `DFInterceptor.runPostInstallInterceptors`.
    * Finally, it calls `DFInterceptor.fetchAndSetDynamicScreen` to get the Composable lambda registered by the DFM via the `DFComponentRegistry`.
    * Returns `DFRunPostInstallResult.Success` (with the lambda) or `Failure`.
15. **Success/Failure Handling (VM):**
    * **Success:** ViewModel updates `_dynamicScreenContent` with the lambda and sets `_uiState` to `DFComponentState.Success`.
    * **Failure:** ViewModel uses `handleErrorState` to update `_uiState` to `DFComponentState.Error`.
16. **UI Rendering (UI):** `DFComponentActivity` observes `_uiState` and `_dynamicScreenContent`.
    * If `_uiState` is `Success` and `_dynamicScreenContent` is populated, it renders the dynamic feature's UI lambda.
    * Otherwise, it renders `DFComponentScreen`, which displays content based on the current `_uiState` (Loading, Error, etc.).

## State Management (`DFComponentState`)

* **Purpose:** Represents the high-level state of the feature loading/installation process visible to the user. It drives the UI displayed in `DFComponentActivity` and `DFComponentScreen`.
* **States:**
    * `Loading`: Initial state, or when installation/downloading is in progress.
    * `RequiresConfirmation`: Play Core needs user permission to proceed (e.g., large download). The Activity listens for events to show the system dialog.
    * `Error`: An error occurred (validation, network, installation, etc.). Contains details about the error.
    * `Success`: The feature is installed, and post-install steps (including fetching the UI lambda) are complete. The Activity uses this state in conjunction with `dynamicScreenContent` to show the feature.
* **Management:** The `DFComponentViewModel` manages the `_uiState: MutableStateFlow<DFComponentState>`. This state is updated based on results from Use Cases (`DFLoadFeatureUseCase`, `DFRunPostInstallStepsUseCase`) and events from `DFMonitorInstallationUseCase`. The `DFHandleInstallationStateUseCase` plays a key role in translating lower-level `DFInstallationState` into the appropriate `DFComponentState`.
* **Observation:** The `DFComponentActivity` and `DFComponentScreen` observe the `uiState` using `collectAsStateWithLifecycle` to reactively update the UI.

## Intent Handling (`DFComponentIntent`)

* **Purpose:** Represents actions initiated by the user or the system (like receiving an Activity Intent) that require processing by the `DFComponentViewModel`. This follows the MVI (Model-View-Intent) pattern principle where the UI sends intents to the ViewModel to trigger logic.
* **Intents:**
    * `ProcessUri(uri)`: Sent by the Activity when it receives an Intent containing a URI. Triggers URI parsing.
    * `LoadFeature(feature, params)`: Typically sent internally by the ViewModel after `ProcessUri` succeeds, or could be triggered directly. Initiates the core feature loading flow.
    * `Retry`: Sent by the UI (e.g., `DFComponentScreen`'s retry button) when an error occurs. Triggers `retryLastFeature`.
    * `UserConfirmationResult(feature, confirmed)`: Sent by the Activity after the user responds to the Play Core confirmation dialog.
* **Processing:** The ViewModel's `processIntent` function acts as the central dispatcher, routing each intent type to a dedicated private handler function (`handleProcessUriIntent`, `loadFeature`, `retryLastFeature`, `handleUserConfirmationResult`). These handlers contain the logic to interact with Use Cases and update state.

## How to Use (For Feature Teams)

1.  **Create DFM:** Set up your dynamic feature module in the project.
2.  **Implement `DFComponentEntry`:** Create a class in your DFM that implements `com.kuru.featureflow.component.register.DFComponentEntry`.
    ```kotlin
    // In your DFM (e.g., :feature_myfeature)
    import com.kuru.featureflow.component.register.*
    import dagger.hilt.android.EntryPointAccessors
    import javax.inject.Inject // If needed within your entry

    class MyFeatureEntry : DFComponentEntry {
        override fun initialize(context: Context) {
            // 1. Get the Hilt EntryPoint to access the Registry
            val entryPoint = EntryPointAccessors.fromApplication(
                context.applicationContext,
                DFRegistryEntryPoint::class.java
            )
            val registry = entryPoint.getComponentRegistry()

            // 2. Define your feature's configuration
            val config = DFComponentConfig(
                route = "myfeature", // Unique route/module name
                listOfDFComponentInterceptor = listOf(
                    // Add pre/post install interceptors if needed
                    // DFComponentInterceptor(preInstall = false) { /* task */ true }
                )
            )

            // 3. Register your feature's config and main screen Composable
            registry.register(config) { navController, params ->
                // Your main Composable screen for this feature
                MyFeatureScreen(navController = navController, params = params)
            }
        }
    }
    ```
3.  **Declare Service:** Declare your `DFComponentEntry` implementation in the DFM's `src/main/resources/META-INF/services/com.kuru.featureflow.component.register.DFComponentEntry` file (create this path if it doesn't exist). The file should contain the fully qualified name of your implementation class:
    ```
    com.yourpackage.feature_myfeature.MyFeatureEntry
    ```
4.  **Build:** Ensure your DFM is correctly configured in your app's build files.

## Dependencies

* Play Core Install API (`com.google.android.play:core`)
* Hilt (`com.google.dagger:hilt-android`)
* Jetpack Compose (`androidx.compose.ui`, `androidx.compose.material3`, `androidx.lifecycle:lifecycle-runtime-compose`, `androidx.activity:activity-compose`)
* Coroutines & Flow (`org.jetbrains.kotlinx:kotlinx-coroutines-core`, `org.jetbrains.kotlinx:kotlinx-coroutines-android`)
* DataStore Preferences (`androidx.datastore:datastore-preferences`)
* Navigation Compose (`androidx.navigation:navigation-compose`) - For Compose screens within features.